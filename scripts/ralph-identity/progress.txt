# Ralph Progress Log — Identity Resolution
Started: (pending Eve migration completion)

## Codebase Patterns
- Use raw SQL, not ORM (user rule)
- No __init__.py files needed
- modernc.org/sqlite for pure-Go SQLite
- JSON output support via --json flag on all commands
- XDG-compliant paths for config/data
- UUID generation with github.com/google/uuid
- Time as Unix timestamps (INTEGER)
- Existing packages to reference:
  - internal/identify/ - existing identity resolution code
  - internal/db/db.go - database connection patterns
  - internal/query/ - query building patterns
  - internal/adapters/ - data sync patterns

## Key Files
- docs/IDENTITY_RESOLUTION_PLAN.md - the spec
- prompts/pii-extraction-v1.prompt.md - extraction prompt
- internal/db/schema.sql - current schema
- internal/identify/suggestions.go - existing merge suggestions (to extend)

## Design Decisions
1. Identifier-centric resolution: O(F) not O(P²)
   - GROUP BY fact_value, find collisions
   - Don't compare all person pairs

2. Hard vs soft identifiers:
   - Hard: 1 match = merge candidate (email, phone, full_name)
   - Compound: all parts match = merge (name+birthdate, name+employer+city)
   - Soft: accumulate weighted scores (employer 0.20, location 0.15, etc.)
   
3. Professional distinction:
   - employer_current = work FOR someone
   - business_owned = OWN a business
   - business_role = Owner, Partner, Founder

4. Integration with analysis framework:
   - PII extraction is an analysis_type
   - Output to facets table, sync to person_facts
   - Leverages existing conversations and analysis_runs

5. Unattributed facts:
   - Phone/email sent without context goes to unattributed_facts
   - Can be resolved later when context available

6. Schema evolution pattern:
   - Use CREATE TABLE IF NOT EXISTS for idempotent migrations
   - Increment schema_version with INSERT OR IGNORE
   - Build & init must succeed before committing

---

## 2026-01-13 - [US-030] Add person_facts table to schema
- Added person_facts table to internal/db/schema.sql
- Includes all fields: id, person_id FK, category, fact_type, fact_value
- Confidence scoring (0.0-1.0) and source attribution
- Three classification flags: is_sensitive, is_identifier, is_hard_identifier
- Evidence field stores quote from original message
- UNIQUE constraint on (person_id, category, fact_type, fact_value) prevents duplicates
- Four indexes: person_id, (category, fact_type), fact_value, and conditional hard_id index
- Schema version incremented from 3 to 4
- Files changed: internal/db/schema.sql
- **Learnings:**
  - WHERE clause on CREATE INDEX is supported in SQLite for conditional indexes
  - This enables efficient queries on hard identifiers without scanning all facts
  - Schema version uses INSERT OR IGNORE, only applies on fresh DBs (existing stay at previous version)
  - comms init is idempotent - safe to run multiple times

---

## 2026-01-13 - [US-031] Add unattributed_facts table to schema
- Added unattributed_facts table to internal/db/schema.sql
- Captures ambiguous data extracted without clear attribution
- Fields: id, fact_type, fact_value, shared_by_person_id, source_event_id, source_conversation_id
- Resolution tracking: resolved_to_person_id, resolution_evidence, resolved_at
- possible_attributions as JSON array for LLM guesses
- Two indexes: (fact_type, fact_value) for lookups, conditional on unresolved
- Schema version incremented from 4 to 5
- Files changed: internal/db/schema.sql
- **Learnings:**
  - Unattributed facts enable graceful handling of "send this to 555-1234" cases
  - Later context ("that's my sister's number") can resolve attribution
  - Conditional index on NULL check is efficient for "unresolved only" queries
  - Pattern: extraction creates unattributed fact, resolution moves to person_facts

---

## 2026-01-13 - [US-032] Add merge_events table to schema
- Added merge_events table to internal/db/schema.sql
- Tracks full lifecycle of identity merges from suggestion to execution
- Fields: id, source_person_id, target_person_id, merge_type, triggering_facts (JSON)
- Status: pending, accepted, rejected, executed
- auto_eligible flag for high-confidence matches (>=0.8 hard identifier collisions)
- Audit trail: similarity_score, resolved_at, resolved_by
- Two indexes: status for filtering workflows, (source, target) for deduplication
- Schema version incremented from 5 to 6
- Files changed: internal/db/schema.sql
- **Learnings:**
  - merge_events replaces merge_suggestions with richer state machine
  - Supports both auto-merge flow and manual review flow
  - triggering_facts as JSON allows storing arbitrary evidence
  - resolved_by distinguishes 'auto' vs user-approved merges
  - Composite index on (source, target) prevents duplicate suggestions

---

## 2026-01-13 - [US-033] Create fact management utilities
- Created internal/identify/facts.go with comprehensive fact management
- Implemented PersonFact struct matching person_facts schema
- Defined 17 hard identifier constants (email, phone, social handles, government IDs)
- Defined 6 soft identifier constants with weights (employer 0.20, location 0.15, profession 0.15, spouse 0.25, school 0.15, birthdate 0.25)
- Implemented InsertFact with ON CONFLICT upsert pattern
- Implemented GetFactsForPerson, GetHardIdentifiers, GetFactsByType, GetFactsByCategory
- Implemented FindFactCollisions with O(F) algorithm using GROUP BY fact_value
- Implemented FindAllHardIdentifierCollisions for resolution pipeline
- Created comprehensive unit tests in facts_test.go
- Files changed: internal/identify/facts.go (new), internal/identify/facts_test.go (new), AGENTS.md
- **Learnings:**
  - ON CONFLICT DO UPDATE with MAX(confidence, excluded.confidence) keeps highest confidence on duplicate
  - SQLite GROUP_CONCAT uses comma separator by default for person ID lists
  - isIdentifierType checks both HardIdentifiers list and SoftIdentifierWeights map
  - Automatic flag setting (is_identifier, is_hard_identifier) based on fact type prevents manual errors
  - Fact collision detection via GROUP BY is O(F) not O(P²) - scales to millions of facts
  - Evidence field stores original message quote for audit trail
  - Three-tier identifier taxonomy: hard (1 match = merge), compound (multi-field), soft (weighted scoring)
  - PersonFact struct uses pointers for optional fields (SourceChannel, Evidence, etc.)
  - splitPersonIDs helper manually parses comma-separated string (no strings.Split to avoid imports)
  - Tests verify constants, helpers, and type detection logic without requiring database
  - boolToInt helper converts Go bool to SQLite INTEGER (0 or 1)

---
## 2026-01-13 - [US-034] Register pii_extraction_v1 as analysis_type
- Added INSERT OR IGNORE statement to schema.sql to register pii_extraction_v1 analysis type
- Configured as 'structured' output_type for facet extraction
- Created facets_config_json with 27 extraction rules mapping JSON paths to fact types
- Extraction paths cover all major PII categories: contact info, core identity, professional, location, relationships, education, digital identity, government IDs
- Embedded full PII extraction prompt from prompts/pii-extraction-v1.prompt.md
- Configured to use gemini-2.0-flash model for extraction
- Prompt includes comprehensive instructions for attribution, confidence levels, and handling unattributed facts
- Files changed: internal/db/schema.sql
- **Learnings:**
  - INSERT OR IGNORE pattern allows idempotent schema migrations without version incrementing
  - Embedded SQL can contain complex JSON and multi-line strings with proper escaping
  - facets_config_json structure: array of objects with facet_type, json_path, category, fact_type
  - JSON path syntax $.persons[*].pii.category.field.value traverses nested extraction output
  - Prompt template uses {conversation_text} placeholder for conversation injection
  - Single quotes in SQL strings require escaping with double single quotes ('')
  - Analysis types table integrates with existing analysis_runs and facets tables from Eve migration
  - Model field allows different LLMs for different analysis types (gemini-2.0-flash for cost-effective PII extraction)
  - JSON extraction rules enable automatic facet creation from structured LLM output without custom parsing code

---


---

## 2026-01-13 - [US-035] Implement facet to person_facts sync
- Verified internal/identify/sync.go already implements comprehensive facet-to-fact sync
- SyncFacetsToPersonFacts queries completed pii_extraction analysis runs and processes facets
- FacetToFactMapping maps 27 facet types to fact types with categories
- syncAnalysisRun processes facets per analysis run, extracting confidence and evidence from metadata_json
- Handles unattributed facts when person_id is NULL - creates unattributed_facts records
- ProcessPIIExtractionOutput handles full LLM JSON output structure with persons array
- Creates third-party person records from new_identity_candidates in extraction output
- Processes unattributed_facts array from extraction output
- mapFactKey and mapCategory functions normalize extraction output keys to fact constants
- Confidence mapping: high=0.9, medium=0.7, low=0.4
- Source type detection: self_disclosed vs mentioned vs inferred
- Evidence combines multiple evidence strings from array with semicolon separator
- Files changed: internal/identify/sync.go (verified), internal/identify/sync_test.go (verified)
- **Learnings:**
  - Sync has TWO paths: facet-based (from facets table) and direct JSON (from full LLM output)
  - SyncFacetsToPersonFacts processes already-stored facets (post-analysis)
  - ProcessPIIExtractionOutput processes raw JSON output (during analysis)
  - Both paths handle third-party creation and unattributed facts
  - Facet metadata_json stores source_type and evidence for fact attribution
  - ON CONFLICT DO NOTHING pattern in unattributed_facts prevents duplicate ambiguous data
  - Person lookup for primary contact uses identities table JOIN
  - Person lookup for non-primary uses fuzzy LIKE match on canonical_name/display_name
  - Array values in extraction output (nicknames, children) require iteration to create multiple facts
  - isSensitiveFactType marks SSN, passport, drivers_license as sensitive (is_sensitive=1)
  - Tests verify mapping consistency between facet types and fact types
  - SyncSingleRun allows processing individual analysis runs by ID
  - Stats tracking provides visibility: facets processed, facts created, unattributed created, third parties created

---

## 2026-01-13 - [US-036] Create extraction CLI command
- Verified comms extract pii command fully implemented in cmd/comms/main.go
- Command enqueues PII extraction jobs via compute engine
- --channel flag filters conversations by channel (imessage, gmail, all)
- --since flag supports multiple formats: 30d (days), 7d, 2024-01-01 (date)
- --conversation flag processes single conversation by ID
- --person flag finds conversations involving person (LIKE match on canonical_name/display_name)
- --dry-run flag shows what would be processed without enqueueing jobs
- --limit flag caps number of conversations to process
- Query excludes conversations already analyzed (NOT EXISTS on analysis_runs)
- Integrates with compute engine: EnqueueAnalysis creates analysis_runs
- JSON output support via global --json flag
- Additional commands: extract sync (facets → person_facts), extract status (show progress)
- Files verified: cmd/comms/main.go (lines 4687-5039)
- **Learnings:**
  - Extract command has 3 subcommands: pii (enqueue), sync (process facets), status (show progress)
  - Query builder pattern: start with base SQL, append WHERE clauses based on flags
  - Time parsing supports duration format (30d, 7h) AND date format (2006-01-02)
  - Person filter joins through conversation_events → event_participants → persons
  - NOT EXISTS subquery prevents re-analyzing conversations (idempotent)
  - Dry-run shows first 10 conversation IDs for preview
  - Compute engine handles actual LLM calls and result storage
  - EnqueueAnalysis creates pending analysis_runs, later processed by compute run
  - Separation of concerns: extract pii = job creation, compute run = job execution
  - Result struct pattern: OK bool, counts, Message for user feedback
  - Cobra command flags: StringVar/BoolVar/IntVar for strongly-typed CLI args
---

## 2026-01-13 - [US-036] Create extraction CLI command
- Verified comms extract pii command already fully implemented in cmd/comms/main.go (lines 4700-4885)
- Command provides all required flags: --channel, --since, --conversation, --person, --dry-run, --limit
- Filters conversations that haven't been analyzed yet (NOT EXISTS subquery on analysis_runs)
- --channel flag filters by channel (imessage, gmail, etc.)
- --since supports multiple formats: "30d", "7d", "2024-01-01" (days, hours, date)
- --conversation processes specific conversation by ID
- --person finds conversations involving specific person (fuzzy name match via LIKE)
- --dry-run shows what would be processed without enqueueing jobs
- Enqueues PII extraction jobs via compute.Engine.EnqueueAnalysis()
- Requires GEMINI_API_KEY environment variable for LLM calls
- Additional commands: comms extract sync (sync facets to person_facts), comms extract status (show extraction progress)
- JSON output support via --json flag
- Files: cmd/comms/main.go (lines 4687-5040)
- **Learnings:**
  - extract pii uses compute engine's EnqueueAnalysis to queue jobs asynchronously
  - Jobs are processed by "comms compute run" command
  - Query excludes already-processed conversations to prevent re-extraction
  - Duration parsing: --since supports "30d" days, "7d" hours, or "2006-01-02" date format
  - Person filtering joins: conversation_events → event_participants → persons
  - Dry-run shows conversation IDs if <= 10 conversations for visibility
  - extract sync calls identify.SyncFacetsToPersonFacts() to sync completed runs
  - extract status shows breakdown by analysis run status (pending/running/completed/failed/blocked)
  - Result structs provide structured JSON output with OK bool, counts, and message

---

## 2026-01-13 - [US-037] Implement third-party identity creation
- Verified ProcessPIIExtractionOutput in internal/identify/sync.go handles third-party creation (lines 341-376)
- Processes new_identity_candidates array from LLM extraction output
- Creates new person records with relationship_type='third_party'
- Generates new UUID for each third-party person
- Uses candidate.Reference as canonical_name, or given_name from known_facts if available
- Links known_facts to new person as person_facts with category=core_identity
- Sets source_type='mentioned' for third-party facts (not self-disclosed)
- Tracks creation with stats.ThirdPartiesCreated counter
- Works seamlessly with facet-based sync (both paths handle third parties)
- Files: internal/identify/sync.go (lines 341-376)
- **Learnings:**
  - Third-party creation integrated into sync pipeline, not separate command
  - new_identity_candidates structure: {reference, known_facts map, note}
  - Known facts are minimal: typically just given_name and relationship_to_primary
  - Confidence set to 0.5 for third-party facts (medium confidence)
  - Third parties can later be merged with existing persons via resolution
  - Type assertion pattern: factValue.(string) to extract string from interface{}
  - Error handling: silently skip if person creation fails (don't block sync)
  - Stats tracking enables visibility into how many third parties are discovered

