# Cortex Memory System — Progress Log

## Codebase Patterns

*(Add reusable patterns here as you discover them)*

### Project Structure
- `cmd/cortex/` — CLI entry point
- `internal/db/` — Database layer, schema.sql
- `internal/` — Core packages
- `prompts/graphiti/` — LLM prompts for extraction

### Schema Conventions
- Tables use snake_case
- Primary keys are TEXT (UUIDs)
- Timestamps are INTEGER (Unix epoch) or TEXT (ISO 8601)
- JSON fields end with `_json` suffix
- Foreign keys have ON DELETE CASCADE where appropriate

### Go Conventions
- Packages are lowercase, single word when possible
- Structs match table names in PascalCase
- Use context.Context for cancellation
- Errors are returned, not panicked

### Naming: Segments → Episodes
- **Schema**: `episodes`, `episode_definitions`, `episode_events` tables
- **Go code**: Use `Episode*` types and `episode*` variables
- **SQL queries**: Reference `ee.episode_id` not `se.segment_id`
- **JSON**: Can keep `segment_id` in JSON for backward compatibility with queued jobs
- **CLI output**: Use "episodes" in user-facing messages

---

## Progress Log

*(Append entries below as stories are completed)*

---
## 2026-01-21 - [MS-001] Rename segments to episodes in Go code
- Renamed all Go code references from `segment` to `episode`
- Updated SQL queries in engine.go, nexus_cli.go, aix_facets.go, main.go, aix.go
- Updated struct fields: `SegmentID` → `EpisodeID`, `SegmentsCreated` → `EpisodesCreated`
- Updated function names: `buildSegmentText` → `buildEpisodeText`, `getSegmentPreview` → `getEpisodePreview`
- Schema was already correct (episodes, episode_events, episode_definitions)
- JSON keys kept as `segment_id` in AnalysisJobPayload for backward compatibility with queued jobs

**Files changed:**
- `internal/compute/engine.go` - SQL queries, struct fields, function names
- `internal/compute/nexus_cli.go` - SQL queries, function signatures
- `internal/adapters/aix_facets.go` - SQL queries, struct fields, function names
- `internal/live/aix.go` - Log message output field
- `cmd/cortex/main.go` - CLI result structs, SQL queries, function names
- `AGENTS.md` - Schema quick reference
- `scripts/ralph-memory/progress.txt` - This entry

**Learnings:**
- The schema.sql was already migrated to use `episodes` terminology
- Go code had many lingering references to `segment_events` table and `segment_id` columns
- SQL column names must match schema exactly - was getting silent failures before
- Keep JSON keys stable for backward compatibility with queued jobs
- search/types.go already had backward compatibility aliases (SegmentSearchRequest = EpisodeSearchRequest)

---
## 2026-01-21 - [MS-002] Add entities table to schema
- Added `entities` table to schema.sql following spec §3.4
- Columns: id, canonical_name, entity_type_id, summary, summary_updated_at, origin, confidence, merged_into, created_at, updated_at
- Added indexes: idx_entities_type (entity_type_id), idx_entities_name (canonical_name)
- Schema version incremented from 13 to 14
- Uses TEXT for timestamps (ISO 8601 format) per spec convention
- entity_type_id maps to code-defined types (0=Entity, 1=Person, 2=Company, 3=Project, 4=Location, 5=Event, 6=Document, 7=Pet)

**Files changed:**
- `internal/db/schema.sql` - Added entities table and indexes

**Learnings:**
- Schema uses TEXT for timestamp columns with ISO 8601 format (not INTEGER Unix epoch like some older tables)
- merged_into uses self-referential FK for tracking entity merges
- Table has IF NOT EXISTS clause for safe re-application
- Indexes also use IF NOT EXISTS for idempotent schema application

---
## 2026-01-21 - [MS-003] Add entity_aliases table to schema
- Added `entity_aliases` table to schema.sql following spec §3.4
- Columns: id, entity_id (FK to entities), alias, alias_type, normalized, is_shared, created_at
- NO UNIQUE constraint on alias - same alias can map to multiple entities (family phone, team email)
- Added indexes: idx_entity_aliases_lookup (alias, alias_type), idx_entity_aliases_normalized (normalized, alias_type), idx_entity_aliases_entity (entity_id)
- Schema version incremented from 14 to 15
- alias_type values: 'name', 'email', 'phone', 'handle', 'username', 'nickname'

**Files changed:**
- `internal/db/schema.sql` - Added entity_aliases table and indexes

**Learnings:**
- Entity aliases are intentionally NOT unique to support shared identifiers (family phone, team email)
- is_shared BOOLEAN field tracks when multiple entities share an alias for disambiguation during resolution
- Identity relationships (HAS_EMAIL, HAS_PHONE, HAS_HANDLE) get promoted to aliases table, not stored in relationships table
- normalized column enables case-insensitive matching without runtime LOWER() calls

---
## 2026-01-21 - [MS-004] Add relationships table to schema
- Added `relationships` table to schema.sql following spec §3.4
- Columns: id, source_entity_id (FK to entities), target_entity_id (FK nullable), target_literal, relation_type, fact, valid_at, invalid_at, created_at, confidence
- CHECK constraint ensures exactly one of target_entity_id or target_literal is NOT NULL
- Conditional UNIQUE indexes:
  - `idx_relationships_unique_entity` on (source_entity_id, target_entity_id, relation_type, valid_at) WHERE target_entity_id IS NOT NULL
  - `idx_relationships_unique_literal` on (source_entity_id, target_literal, relation_type, valid_at) WHERE target_literal IS NOT NULL
- Regular indexes: source, target, type, temporal bounds
- Schema version incremented from 15 to 16

**Files changed:**
- `internal/db/schema.sql` - Added relationships table and indexes

**Learnings:**
- SQLite supports conditional UNIQUE indexes via `WHERE` clause - useful for enforcing different uniqueness constraints based on which column is populated
- CHECK constraint syntax in SQLite is straightforward for XOR-style validation
- Bi-temporal model uses TEXT for timestamps (ISO 8601) to match entity/alias tables
- valid_at allows NULL (unknown when relationship started) but enables different relationships with same (source, target, type) if they have different valid_at values (e.g., multiple job stints at same company)

---
## 2026-01-21 - [MS-005] Add episode_entity_mentions table to schema
- Added `episode_entity_mentions` junction table to schema.sql following spec §3.4
- Columns: episode_id (FK to episodes), entity_id (FK to entities), mention_count (default 1), created_at
- Composite PRIMARY KEY on (episode_id, entity_id) - ensures one record per episode-entity pair
- Added ON DELETE CASCADE for both foreign keys to maintain referential integrity
- Index: idx_episode_entity_mentions_entity (entity_id) for efficient entity-based lookups
- Schema version incremented from 16 to 17

**Files changed:**
- `internal/db/schema.sql` - Added episode_entity_mentions table and index

**Learnings:**
- Junction tables with composite PKs don't need separate id columns - the composite PK serves as the unique identifier
- ON DELETE CASCADE is important for junction tables referencing entities that may be merged/deleted
- The mention_count column enables tracking how many times an entity is referenced within an episode (useful for relevance scoring)
- Table positioned after relationships and before upcoming episode_relationship_mentions to maintain logical grouping

---
## 2026-01-21 - [MS-006] Add episode_relationship_mentions table to schema
- Added `episode_relationship_mentions` table to schema.sql following spec §3.4
- Columns: id, episode_id (FK), relationship_id (FK nullable), extracted_fact, asserted_by_entity_id (FK nullable), source_type, target_literal, alias_id (FK nullable), confidence, created_at
- relationship_id is nullable because identity relationships (HAS_EMAIL, HAS_PHONE, HAS_HANDLE) go to entity_aliases instead of relationships table
- Added ON DELETE CASCADE for episode_id and relationship_id FKs
- Added ON DELETE SET NULL for alias_id FK (preserve provenance even if alias is later deleted)
- Added indexes: idx_episode_rel_mentions_episode (episode_id), idx_episode_rel_mentions_relationship (relationship_id)
- Schema version incremented from 17 to 18

**Files changed:**
- `internal/db/schema.sql` - Added episode_relationship_mentions table and indexes

**Learnings:**
- episode_relationship_mentions is a "provenance table" - it tracks WHERE facts came from, even if the same fact is extracted multiple times
- Identity relationships (HAS_EMAIL, HAS_PHONE) populate this table with relationship_id=NULL and alias_id pointing to the created alias
- The extracted_fact column preserves the original text (pre-dedup), useful for debugging and taxonomy evolution
- asserted_by_entity_id enables tracking WHO said something (speaker attribution) vs the episode itself
- source_type ('self_disclosed', 'mentioned', 'inferred') is critical for confidence scoring - self_disclosed facts are higher confidence

